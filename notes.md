GitHub usage:
- git clone link
- git pull
- git add ThingBeingAdded
- git commit -am "Commit Notes"
- git push
- git fetch
- git status
  
The Internet:

- HTTPS and TLS: (Hypertext Transport Protocol, negotiated secure connection that happens before any data is exchanged. Having a secure connection means that all the data is encrypted using the TLS protocol. TLS is sometimes referred to by a now unsecure predecessor protocol named SSL)
  curl -v -s https://byu.edu > /dev/null

- Web certificates: (generated by a trusted 3rd party using public/private key encryption. certificate can only be used by certificate owner and they can validate it by using the public keys of the certificate issuer. Used to be expensive but after 2014 2 Mozilla employees created a non-profit called Let's Encrypt and tried to make web certificates free. Caddy uses Let's Encrypt to generate a web certificate every time an HTTPS request is made for a domain name that Caddy doesn't have a web certificate for to get it from the owner. Let's Encrypt does that by telling the requester to return a specific digitally signed response for a temporary URL when an HTTP request to the domain is made. Let's Encrypt then makes the HTTP request, and if successful, issues the certificate to the requester)

- Enabling HTTPS: (Modern browsers all user HTTPS for all communication. Not difficult to do)

- Caddy: (Uses caddy as a gateway to our different services and to host the static web application files. Caddy has ACME support built into it by default, and so all you need to do is configure Caddy with the domain name for the web server)
- Caddy 2: (Listens for incoming HTTP requests. Then either serves up the requested static files or routes the request to another web servie. The ability to route requests is called a gateway or reverse proxy and allows to expose multiple web servies as a single external web service. Port 443 connects to Caddy which connects to the html and web domain (port 3001, node.js app)
  Caddy handles all of the creation and rotation of web certifiacates. This allows us to easily support HTTPS
  Caddy serves up all of your static HTML, CSS, and js files. All of the early application work will be hosted as static files
  Caddy acts as a gateway for subdomain request to your Simon and startup services. For example, when a request is made to the site, Caddy will proxy the request to the application running with node.js as an internal web service

- Amazon Web Services, AWS, Route 53: (Route 53 is the AWS service that handles everything DNS-related. With route 53 you can buy a domain name, host your domain on their DNS servers and create DNS records. EC2 server allows 2 different names and gives a domain name for elastic IP address)

- Domain names are used in place of IP's since they are long and hard to remember. Determine the hops in a connection using the traceroute console utility. Trace the route between 2 computers.

- TCP/IP layers
  Application - HTTPS, functionality like web browsing
  Transport - TCP, moving connection information packets
  Internet - IP, establishing connections
  Link - Fiber, hardware, physical connections

- Domain names: (domain name: [subdomain.]*secondary.top, root: secondary.top, react.simon.cs260.click, root: cs260.click)

- DNS: (domain name system, list of domains with server and associated with an IP address)

- Image service - port 3000
- Authentication service - port 3001
- File service 3002
















HTML:
- Elements and tags: (elements are represented with enclosing tags that may enclose other elements text. All structure not a lot of style)
  <p>Hello world</p>

  <html>
    <head>
      <title>My First Page</title>
    </head>
    <body>
      <main>
        <p>Hello world</p>
      </main>
    </body>
  </html>

- Attributes: (describe the specific details of the element. ex. id attribute gives a unique ID to the element so that you can distinguish it from other elements. The class attribute is another common element attribute that designates the element as being classified into a named group of elements. Attributes are written inside the element tag with a name followed by an optional value. You can use either ' or " to delimit attribute values)
  <p id="hello" class="greeting">Hello world</p>

- Hyperlinks:
  <a href="https://byu.edu">Go to the Y</a>

- Complete example: (need <!DOCTYPE html> to tell the browser the type and version of the document)
  <!DOCTYPE html>
  <html lang="en">
    <body>
      <main>
        <h1>Hello world</h1>
        <p class="introduction">
          HTML welcomes you to the amazing world of
          <span class="topic">web programming</span>.
        </p>
        <p class="question">What will this mean to you?</p>
        <p class="assignment">Learn more <a href="instruction.html">here</a>.</p>
      </main>
    </body>
  </html>

- Common elements:
  html - page container
  head - header information
  title - title of the page
  meta - metadata for the page such as character set or viewport settings
  script - js reference. either an external reference or inline
  include - external content reference
  body - entire content body of the page
  header - header of the main content
  footer - footer of the main content
  nav - navigational inputs
  main - main content of the page
  section - section of the main content
  aside - aside content from the main content
  div - block division of content
  span - inline span of content
  h<1-9> - text heading from h1, the highest level, down to h9, the lowest level
  p - paragraph of text
  b - bring attention (bold)
  table - table
  tr - table row
  th - table header
  td - table data
  ol, ul - ordered or unordered list
  li - list item
  a - anchor the text to a hyperlink
  img - graphical image reference
  dialog - interactive component such as a confirmation
  form - collection of user input
  audio - audio content
  video - video content
  svg - scalable vector graphic content
  iframe - inline frame of another HTML page
  comments - <!-- commented text -->

- Special characters: (how to show the character instead of being used as it's HTML function)
  & - &amp;
  < = &lt;
  > - &gt;
  " - &quot;
  ' - &apos;
  emoji - &#128512;

- HTML versions:
  1990 - HTML1 - format tags
  1995 - HTML2 - tables, internationalization
  1997 - HTML3 - MathML, CSS, frame tags
  1999 - HTML4 - external CSS
  2014 - HTML5 - email, password, media, and semantic tags

- Stucture elements examples:
  <body>
    <p>Body</p>
    <header>
      <p>Header - <span>Span</span></p>
      <nav>
        Navigation
        <div>Div</div>
        <div>Div</div>
      </nav>
    </header>

    <main>
      <section>
        <p>Section</p>
        <ul>
          <li>List</li>
          <li>List</li>
          <li>List</li>
        </ul>
      </section>
      <section>
        <p>Section</p>
        <table>
          <tr>
            <th>Table</th>
            <th>Table</th>
            <th>Table</th>
          </tr>
          <tr>
            <td>table</td>
            <td>table</td>
            <td>table</td>
          </tr>
        </table>
      </section>
      <aside>
        <p>Aside</p>
      </aside>
    </main>

    <footer>
      <div>Footer - <span>Span</span></div>
    </footer>
  </body>

- Block and inline: (block element is meant to be a distinct block in the flow of the content structure. An inline element is meant to be inline with the content flow of a block element. Inline elements fo not disrupt the flow of a block element's content. Block element div can have an inline element b. p element could have span to make the paragraphs subtext as a person's name)
  <div>He said <b>don't</b> cross the beams.</div>
  <p>Authors such as <span>ee cummings</span> often used unconventional structure.</p>

- Input elements:
  form - input container and submission. ex. <form action="form.html" method="post">
  fieldset - labeled input grouping. ex. <fieldset> ... </fieldset>
  input - multiple types of user input. ex. <input type="" />
  select - selection dropdown. ex. <select><option>1</option></select>
  optgroup - grouped selection dropdown. ex. <optgroup><option>1</option></optgroup>
  option - selection option. ex. <option selected>option2</option>
  textarea - multiline text input. ex. <textarea></textarea> 
  label - individual input label. ex. <label for="range">Range: </label>
  output - output of input. ex. <output for="range">0</output>
  meter - display value with a known range. ex. <meter min="0" max="100" value="50"></meter>

- Form element: (container element that sends the input data to a web server as part of a request. Now js is more commonly used)
  <form action="submission.html" method="post">
    <label for="ta">TextArea: </label>
    <textarea id="ta" name="ta-id">
  Some text
    </textarea>
    <button type="submit">Submit</button>
  </form>

- Input element: (set the type of input with the type attribute)
  text - single line textual value
  password - obscured password
  email - email address
  tel - telephone number
  url - URL address
  number - numerical value
  checkbox - inclusive selection
  radio - exclusive selection
  range - range limited number
  date - year, month, day
  datetime-local - date and time
  month - year, month
  week - week of year
  color - color
  file - local file
  submit - button to trigger form submission

  ex.
  <label for="checkbox1">Check me</label> <input type="checkbox" name="varCheckbox" value="checkbox1" checked />

  (Most input elements share some common attributes including:
  name - name of the input, this is submitted as the name of the input if used in a form
  disabled - disables the ability for the user to interact with the input
  value - initial value of the input
  required - signifies that a value is required in order to be valid

- External media elements:
  image - <img alt="mountain landscape" src="https://images.pexels.com/photos/164170/pexels-photo-164170.jpeg" />
  audio - <audio controls src="testAudio.mp3"></audio>
  video - (may need to include crossorigin="anonymous" attribute if you are requesting files from a different domain than the one serving your content) <video controls width="300" crossorigin="anonymous">
  <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" />
</video>
  SVG - <svg viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg" stroke="red" fill="red" style="border: 1px solid #000000">
  <circle cx="150" cy="100" r="50" />
</svg>
  Canvas - <canvas id="canvasDemo" width="300" height="200" style="border: 1px solid #000000"></canvas>
<script>
  const ctx = document.getElementById('canvasDemo').getContext('2d');
  ctx.beginPath();
  ctx.arc(150, 100, 50, 0, 2 * Math.PI);
  ctx.fillStyle = 'red';
  ctx.strokeStyle = 'red';
  ctx.fill();
  ctx.stroke();
</script>


















CSS:
- 3 ways to associate CSS with HTML.
  style attribute - <p style="color:green">CSS</p>
  style element - <head>
  <style>
    p {
      color: green;
    }
  </style>
</head>
<body>
  <p>CSS</p>
</body>
  link - <link rel="stylesheet" href="styles.css" />
style.css - p {
  color: green;
}

- Cascading styles: (Elements inherit the rules applied to their parents, the same declaration property can be applied to a single element multiple times. The rules cascade down from the highest nodes in the DOM tree to the lowest level. Any declaration defined at a lower level will override the higher declaration. See this in the browser's debugger. In chrome, right click on the element and select inspect. You can then click on each element in the debugger and see what the value of the color property is. For he case defined below, you will see that each of the higher level declarations is crossed out until you get to the style explicitly defined on the element)
  <body>
    <p><span style="color:black">CSS</span></p>
  </body>

  body {
    color: red;
  }
  p {
    color: green;
  }
  span {
    color: blue;
  }

- The box model: (CSS defines everything as boxes. When applying style, it applies them to a region of the display that is a rectangular box. Orger is margin, border, padding, and innermost space. Margin is considered external to the actual styling of the box and represents whitespace.Innermost space has the element's content. Padding inherits things like the background color. The border has properties like color, thickness, and line style. Default sizes: margin(16 top, bottom and - left, right), border(- top, bottom, left, right), padding(8 left and - top, bottom, right), innermost(831x18). Can change box-sizing CSS property from the default value of content-box to border-box in order to redefine the width and height to also include the padding and the border. This often makes it easier to style elements when their visual size matches their actual size)

- CSS versions:
  1996 - CSS1 - selectors, font, color, background, alignment, margin, border, padding
  1998 - CSS2 - positioning, z-index, bidirectional text, shadows
  2011 - CSS2.1 - removed incompatible features
  1999-2021 - CSS3 - enhancements for media, box, background, boaders, color, template, multi-column, selectors

- Selectors:
- Element type selector: 
- Combinators: (To change things of a sections for each depatment, can use a descendant combinator that is defined with a space delimited list of values where each item in the list is a descendant of the previous item)
  section h2 {
    color: #004400;
  }

  (Can use the general sibling combinator to increase the whitespace padding on the left of paragraphs that are siblings of a level two heading)
  h2 ~ p {
    padding-left: 0.5em;
  }

  Other combinators:
  Decendant - a list of decendants. ex. body, section. Any selection that is a decendant of a body
  Child - a list of direct children. ex. section> p. any p that is a direct child of a section
  General sibling - a list of siblings. ex. p ~ div. Any p that has a div sibling
  Adjacent sibling - a list of adjacent siblings. ex. p + div. any p that has an adjacent div sibling
  
- Class selector: (Any element can have 0 or more classifications applied to it. If we want to bold the summary paragraphs we would supply the class name summarty prefixed with a period)
  .summary {
    font-weight: bold;
  }
  (Can also combine the element name and class selectors to select all paragraphs with a class of summary)
  p.summary {
    font-weight: bold;
  }
  
- ID selector: (reference the ID of an element. All ID's should be unique within an HTML document so this select targets a specific element. To use the ID selector you prefix the ID with the #)
  #physics {
    border-left: solid 1em purple;
  }
  
- Attribute selector: (select based upon their attributes. Use an attribute selector to select any element with a given attribute (a[href]). You can also specify a required value for an attribute (a[href="./fish.png"]) in order for the selector to match)
  p[class='summary'] {
    color: red;
  }
  
- Pseudo selector: (select based on positional relationships, mouse interactions, hyperlink visitation states, and attributes)
  section:hover {
    border-left: solid 1em purple;
  }

- CSS declarations:
  background-color - color. ex. red. fill the background color
  boarder - color width style. ex. #fad solid medium. Sets the border using shorthand where any or all of the values may be provided
  border-radius - unit. ex. 50%. the size of the border radius
  box-shadow - x-offset y-offset blu-radius color. ex. 2px 2px 2px gray. creates a shadow
  columns - number. ex. 3. number of textual columns
  column-rule - color width style. ex. solid thin black. sets the border used between columns using border shorthand
  color - color. ex. rgb(128, 0, 0). sets the text color
  cursor - type. ex. grab. sets the cursor to display when hovering over the element
  display - type. ex. none. defines how to display the element and its children
  filter - filter-function. ex. grayscale(30%). applies a visual filter
  float - direction. ex. right. places the element to the left or right in the flow
  flex - flex layout, used for responsive design
  font - family size style. ex. Arial 1.2em bold. defines the text font using shorthand
  grid - grid layout, used for responsive design
  height - unti. ex. .25em. sets the height of the box
  margin - unit. ex. 5px 5px 0 0. sets the margin spacing
  max-[width/height] - unit. ex. 20%. restricts the width or height to no more than the unit
  min-[width/height] - unit. ex. 10vh. restricts the width or height to no less than the unit
  opacity - number. ex. .9. sets how opaque the element is
  overflow - [visible/hidden/scroll/auto]. ex. scroll. defines what happens when the content does not fit in its box
  position - [static/relative/absolute/sticky]. ex. absolute. defines how the element is positioned in the document
  padding - unit. ex. 1em 2em. sets the padding spacing
  left - unit. ex. 10rem. the horizontal value of a positioned element
  text-align - [start/end/center/justify]. ex. end. defined how the text is aligned in the element
  top - unit. ex. 50px. the vertical value of a positioned element
  transform - transform-function. ex. rotate(0.5turn). applies a transformation to the element
  width - unit. ex. 25vmin. sets the width of the box
  z-index - number. ex. 100. controls the positioning of the element on the z axis

- Units:
  p {
    width: 25%;
    height: 30vh;
  }

  px - number of pixels
  pt - number of points (1/72 of an inch)
  in - number of inches
  cm - number of centimeters
  % - percentage of the parent element
  em - multiplier of the width of the letter m in the parent's font
  rem - multiplier of the width of the letter m in the root's font
  ex - multiplier of the height of the element's font
  vw - percentage of the viewport's width
  vh - percentage of the viewport's height
  vmin - percentage of the viewport's smaller dimension
  vmax - percentage of the viewport's larger dimension

- Color
  keyword - ex. red. set of predefined colors(white, cornflowerblue, darkslateblue)
  RGB hex - ex. #00FFAA22 or #0FA2. red, green, and blue as a hexadecimal number, with an optional alpha opacity
  RGB function - ex. rgd(128, 255, 128, 0.5). red, green, and blue as a percentage or number between 0 and 255, with an optional alpha opacity percentage 
  HSL - ex. hsl(180, 30%, 90%, 0.5). hue, saturation, and light with an optional opacity percentage. Hue is the position on the 365 degree color wheel (red is 0 and 155). Saturation is how gray the color is, and light is how bright the color is

- Fonts: (4 major families of fonts: Serif, sans-serif, fixed, and symbol. Use @font-face to import them)
  @font-face {
    font-family: 'Quicksand';
    src: url('https://cs260.click/fonts/quicksand.woff2');
  }
  p {
    font-family: Quicksand;
  }

  (Can be taken from google)
  @import url('https://fonts.googleapis.com/css2?family=Rubik Microbe&display=swap');
  p {
    font-family: 'Rubik Microbe';
  }

- CSS animation: (animation-name refers to the name of the keyframes and given a duration)
  p {  
    text-align: center;
    font-size: 20vh;
    animation-name: demo;
    animation-duration: 3s;
  }

  @keyframes demo {
    from {
      font-size: 0vh;
    }
    to {
      font-size: 20vh;
    }
  }

  @keyframes demo {
    from {
      font-size: 0vh;
    }
    95% {
      font-size: 21vh;
    }
    to {
      font-size: 20vh;
    }
  }

- Display:
  none - don't display this element. the element still exists but the browser will not render it
  block - display this element with a width that fills its parent element. a p or div emelemnt has block display by defailt
  inline - display this element with a width that is only as big as its content. a b or span element has inline display by default
  flex - display this element's children in a flexible orientation
  grid - display this element's children in a grid orientation

  <div class="none">None</div>
  <div class="block">Block</div>
  <div class="inline">Inline1</div>
  <div class="inline">Inline2</div>
  <div class="flex">
    <div>FlexA</div>
    <div>FlexB</div>
    <div>FlexC</div>
    <div>FlexD</div>
  </div>
  <div class="grid">
    <div>GridA</div>
    <div>GridB</div>
    <div>GridC</div>
    <div>GridD</div>
  </div>

  .none {
    display: none;
  }
  .block {
    display: block;
  }
  .inline {
    display: inline;
  }
  .flex {
    display: flex;
    flex-direction: row;
  }
  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
  }

- Viewport meta tag: (for smartphones)
  <meta name="viewport" content="width=device-width,initial-scale=1" />

- Float: (this property moves an element to the left or right of its container element and allows inline elements to wrap around it)
  aside {
    float: right;
    padding: 3em;
    margin: 0.5em;
    border: black solid thin;
  }

- Media queries: (use @media selector to tell which side of the screen (technically the viewport) is the longest. A media query takes one or more predicates separated by boolean operators)
  @media (orientation: portrait) {
    div {
      transform: rotate(270deg);
    }
  }

  @media (orientation: portrait) {
    aside {
      display: none;
    }
  }

- Grid: (responsive grid)
  <div class="container">
    <div class="card"></div>
    <div class="card"></div>
    <div class="card"></div>
    <div class="card"></div>
    <div class="card"></div>
    <div class="card"></div>
    <div class="card"></div>
    <div class="card"></div>
    <div class="card"></div>
  </div>

  .container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    grid-auto-rows: 300px;
    grid-gap: 1em;
  }

- Flex: (useful layout that is used when you want to partition your application into areas that responsively move around as the window resizes or the orientation changes)
  <body>
    <header>
      <h1>CSS flex &amp; media query</h1>
    </header>
    <main>
      <section>
        <h2>Controls</h2>
      </section>
      <section>
        <h2>Content</h2>
      </section>
    </main>
    <footer>
      <h2>Footer</h2>
    </footer>
  </body>

  body {
    display: flex;
    flex-direction: column;
    margin: 0;
    height: 100vh;
  }
  header {
    flex: 0 80px;
    background: hsl(223, 57%, 38%);
  }
  footer {
    flex: 0 30px;
    background: hsl(180, 10%, 10%);
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: row;
  }

  section:nth-child(1) {
    flex: 1;
    background-color: hsl(180, 10%, 80%);
  }
  section:nth-child(2) {
    flex: 3;
    background-color: white;
  }

  @media (orientation: portrait) {
    main {
      flex-direction: column;
    }
  }
  @media (max-height: 700px) {
    header {
      display: none;
    }
    footer {
      display: none;
    }
  }

- Tailwing also is css framework Bootstrap: (for css bootstrap)
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65"
        crossorigin="anonymous"
      />
    </head>
    <body>
      ...
    </body>
  </html>

  <body>
    ...
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
      crossorigin="anonymous"
    ></script>
  </body>

  // Bootstrap styled button
  <button type="button" class="btn btn-primary">Bootstrap</button>
  // Default browser styled button
  <button type="button">Plain</button>



















JavaScript:
- Comments
// Line comment
/*
Block comment
*/

- Basic function
  function join(a, b) {
    return a + ' ' + b;
  }
  console.log(join('Hello', 'world'));
  // OUTPUT: Hello world

-   CSS delarations in log output
  console.log('%c JavaScript Demo', 'font-size:1.5em; color:green;');
  // OUTPUT: JavaScript Demo //in large green text

- Timers
  console.time('demo time');
  // ... some code that takes a long time.
  console.timeEnd('demo time');
  // OUTPUT: demo time: 9762.74 ms

- Counting
  console.count('a');
  // OUTPUT: a: 1
  console.count('a');
  // OUTPUT: a: 2
  console.count('b');
  // OUTPUT: b: 1

- JavaScript in HTML
  js:
  function sayHello() {
    console.log('hello');
  }

  html:
  <head>
  <script src="javascript.js"></script>
  </head>
  <body>
    <button onclick="sayHello()">Say Hello</button>
    <button onclick="sayGoodbye()">Say Goodbye</button>
    <script>
      function sayGoodbye() {
        alert('Goodbye');
      }
    </script>
  </body>

  other parts:
  <button onclick="let i=1;i++;console.log(i)">press me</button>
  <!-- OUTPUT: 2 -->

- Declaring variables:
  let - can chage value of variable
  cont - will cause error if you attempt to change it
  null - type that has not been assigned a value
  undefined - type that has not been defined
  boolean - true or false
  number - 64-bit signed number
  BigInt - number of arbitrary magnitude
  String - textual sequence of characters
  Symbol - unique value
  Object - collection of properties represented by name-value pairs. Values can be of any type ex. {a:3, b:'fish'}
  Function - object that has the ability to be called. ex. function a() {}
  Date - calendar dates and times. ex. new Date('1995-12-17')
  Array - ordered sequence of any type. ex. [3, 'fish']
  Map - collection of key-value pairs that support efficient lookups. ex. new Map()
  JSON - lightweight data-interchange format used to share information across programs. ex. {"a":3, "b":"fish"}

- Common operators:
  has all common plus concatenation and strict equality (===) and inequality (!==)

- Examples of weakly typed language: (variable type can change at any given point)
  2 + '3';
  // OUTPUT: '23'
  2 * '3';
  // OUTPUT: 6
  [2] + [3];
  // OUTPUT: '23'
  true + null;
  // OUTPUT: 1
  true + undefined;
  // OUTPUT: NaN
  1 == '1';
  // OUTPUT: true
  null == undefined;
  // OUTPUT: true
  '' == false;
  // OUTPUT: true
  1 === '1';
  // OUTPUT: false
  null === undefined;
  // OUTPUT: false
  '' === false;
  // OUTPUT: false

- Conditionals:
  if (a === 1) {
    //...
  } else if (b === 2) {
    //...
  } else {
    //...
  }

  a === 1 ? console.log(1) : console.log('not 1');

  if (true && (!false || true)) {
    //...
  }

- Loops:
  for:
  for (let i = 0; i < 2; i++) {
    console.log(i);
  }
  // OUTPUT: 0 1

  do while:
  let i = 0;
  do {
    console.log(i);
    i++;
  } while (i < 2);
  // OUTPUT: 0 1

  while:
  let i = 0;
  while (i < 2) {
    console.log(i);
    i++; 
  }
  // OUTPUT: 0 1

  for in: (iterates over an object's property names)
  const obj = { a: 1, b: 'fish' };
  for (const name in obj) {
    console.log(name);
  }
  // OUTPUT: a
  // OUTPUT: b

  (for arrays the object's name is the array index)
  const arr = ['a', 'b'];
  for (const name in arr) {
    console.log(name);
  }
  // OUTPUT: 0
  // OUTPUT: 1

  for of: (iterates over an iterable's (Array, Map, Set, ...) preperty values)
  const arr = ['a', 'b'];
  for (const val of arr) {
    console.log(val);
  }
  // OUTPUT: 'a'
  // OUTPUT: 'b'

  Break and continue: (all of the looping constructs above allow either a break or continue to abort or advance the loop)
  let i = 0;
  while (true) {
    console.log(i);
    if (i === 0) {
      i++;
      continue;
    } else {
      break;
    }
  }
  // OUTPUT: 0 1

- Strings:
  string variable is specified by surrounding a sequence of characters with ', ", or `. Single or double quotes are equivalent, but the backtick defines a string literal that may contain js that is evaluated in place and concatenated into the string. A string literal replacement specifier is declared with a dollar sign followed by a curly brace pair. Anything inside is evaluated as js. Backticks can also create multiling string without having to explicitly espace the newline character(\n).
  
  'quoted text'; // " also works
  const l = 'literal';
  console.log(`string ${l + (1 + 1)} text`);
  // OUTPUT: string literal2 text

- String Functions:
  length - number of characters in the string
  indexOf() - the starting index of a given substring
  split() - split the string into an array on the givern delimiter string
  startsWith() - true if the string has the given prefix
  endsWith() - true if the string has the given suffix
  toLowerCase() - converts all characters to lowercase

  ex.
  const s = 'Example:조선글';
  console.log(s.length);
  // OUTPUT: 11
  console.log(s.indexOf('조선글'));
  // OUTPUT: 8
  console.log(s.split(':'));
  // OUTPUT: ['Example', '조선글']
  console.log(s.startsWith('Ex'));
  // OUTPUT: true
  console.log(s.endsWith('조선글'));
  // OUTPUT: true
  console.log(s.toLowerCase());
  // OUTPUT: example:조선글
  
- Function parameters: (if parameter is not provided then the value is undefined)
  function labeler(value, title = 'title') {
    console.log(`${title}=${value}`);
  }
  labeler();
  // OUTPUT: title=undefined
  labeler('fish');
  // OUTPUT: title=fish
  labeler('fish', 'animal');
  // OUTPUT: animal=fish

- Anonymous functions: (commonly assigned to a variable to they can be passed as a parameter to some other function or stored as an object property)
  // Function that takes a function as a parameter
  function doMath(operation, a, b) {
    return operation(a, b);
  }
  // Anonymous function assigned to a variable
  const add = function (a, b) {
    return a + b;
  };
  console.log(doMath(add, 5, 3));
  // OUTPUT: 8
  // Anonymous function assigned to a parameter
  console.log(
    doMath(
      function (a, b) {
        return a - b;
      },
      5,
      3
    )
  );
  // OUTPUT: 2

- Creating, passing, and returning functions:
  // Anonymous declaration of the function that is later assigned to a variable
  const add = function (a, b) {
    return a + b;
  };
  // Function that logs as a side effect of its execution
  function labeler(label, value) {
    console.log(label + '=' + value);
  }
  // Function that takes a function as a parameter and then executes the function as a side effect
  function addAndLabel(labeler, label, adder, a, b) {
    labeler(label, adder(a, b));
  }
  // Passing a function to a function
  addAndLabel(labeler, 'a+b', add, 1, 3);
  // OUTPUT: a+b=4
  // Function that returns a function
  function labelMaker(label) {
    return function (value) {
      console.log(label + '=' + value);
    };
  }
  // Assign a function from the return value of the function
  const nameLabeler = labelMaker('name');
  // Calling the returned function
  nameLabeler('value');
  // OUTPUT: name=value

- Inner functions: (fuctions can be declared inside other functions. Allows for modularization of code without always exposing private details)
  function labeler(value) {
    function stringLabeler(value) {
      console.log('string=' + value);
    }
    function numberLabeler(value) {
      console.log('number=' + value);
    }
    if (typeof value == 'string') {
      stringLabeler(value);
    } else if (typeof value == 'number') {
      numberLabeler(value);
    }
  }
  labeler(5);
  // OUTPUT: number=5
  labeler('fish');
  // OUTPUT: string=fish

- Arrow Function: (Functions are first order objects, they can be declared anywhere and passed as parameters. This causes a lot of anonymous functions. To make more compact code, the arrow (=>) was make to replace the need for the function keyword. Can not be used for contructors or iterator generators)
  // Always returns 3
  () => 3;

  Equivalent functions:
  const a = [1, 2, 3, 4];
  // standard function syntax
  a.sort(function (v1, v2) {
    return v1 - v2;
  });
  // arrow function syntax
  a.sort((v1, v2) => v1 - v2);

- Return values: (arrows have special rules with return. Return keyword is optional if no curly braces are provided for the function and it contains a single expression. Result is then automatically returned. If curly braces are provided then the arrow function behaves like a standard function)
  () => 3;
  // RETURNS: 3
  () => {
    3;
  };
  // RETURNS: undefined
  () => {
    return 3;
  };
  // RETURNS: 3
  
- This pointer: (Arrow functions inherit the this pointer from the scope of where it is created which is known as a closure. A closure allows a function to continue referencing its creation scope, even after it has passed out of that scope.)
  ex. (This function returns an anonymous function using the arrow syntax. The a parapeter is overridden, a new b variable is created, and both a and b are referenced in the arrow functions. Because of that reference, they are both part of the closure for the returned function)
  function makeClosure(a) {
    a = 'a2';
    const b = 'b2';
    return () => [a, b];
  }
  (Next a and b are declared at the top level scope, and call makeClosure with a)
  const a = 'a';
  const b = 'b';
  const closure = makeClosure(a);
  (Then, closure is called and will output the values contained in scope where it was created instead of the current values of the variables)
  console.log(closure());
  // OUTPUT: ['a2', 'b2']
  console.log(a, b);
  // OUTPUT: 'a' 'b'

- Putting it all together: (Debounce functions are used to only execute a specified funciton once within a given time window. Any requests to execute the debounce function more frequently than this will cause the time window to reset. This is important when a user can trigger expensive events thousnads of times per second. Without a debounce the performance of your application can greatly suffer. The window.addEventListener function adds a callback function that is invoked whenever the user scolls the browser's web page. The first parameter to addEventListener specifies that it wants to listen for scroll events. The second parameter provides the function to call when a scroll event happens. In this case we would call debounce)
  (Debounce function takes two parameters, the time window for executing the window functions, and the window function to call within that limit. This one will execute at most every 500 milliseconds)
  window.addEventListener(
    'scroll',
    debounce(500, () => {
      console.log('Executed an expensive calculation');
    })
  );
  (The debounce function implements the execution of windowFunc within the restricted time window by creating a closure that contains the current timeout and returning a function that will reset the timeout every time it is called. The returned function is what the scroll event will actually call when the user scrolls the page. However, instead of directly executing the windowFunc it sets a timer based on the value of windowMs. If the debounce function is called again before the window times out then it resets the timeout)
  function debounce(windowMs, windowFunc) {
    let timeout;
    return function () {
      console.log('scroll event');
      clearTimeout(timeout);
      timeout = setTimeout(() => windowFunc(), windowMs);
    };
  }

- Arrays: (represents a sequence of other objects and primitives. You can reference the members of the array using a zero based index. You can create an array with the Array contructor or using the array literal notation)
  const a = [1, 2, 3];
  console.log(a[1]);
  // OUTPUT: 2
  console.log(a.length);
  // OUTPUT: 3

- Array functions:
  push - add an item to the end of the array. ex. a.push(4)
  pop - remove an item from the end of the array. ex. x = a.pop()
  slice - return a sub-array. ex. a.slice(1, -1)
  sort - run a function to sort an array in place. ex. a.sort((a,b) => b-a)
  values - creates an iterator for use with a for of loop. ex. for(i of a.values()) {}
  find - find the first item satisfied by a test function. ex. a.find(i => i<2)
  forEach - run a function on each array item. ex. a.forEach(console.log)
  reduce - run a function to reduce each array item to a single item. ex. a.reduce((a,c) => a+c)
  map - run a function to map an array to a new array. ex. a.map(i => i+i)
  filter - run a function to remove items. ex. a.filter(i => i%2)
  every - run a function to test if all items match. ex. a.every i => i < 3)
  some - run a function to test if any items match. ex. a.some(i => 1 < 1)
  const a = [1, 2, 3];
  console.log(a.map((i) => i + i));
  // OUTPUT: [2,4,6]
  console.log(a.reduce((v1, v2) => v1 + v2));
  // OUTPUT: 6
  console.log(a.sort((v1, v2) => v2 - v1));
  // OUTPUT: [3,2,1]
  a.push(4);
  console.log(a.length);
  // OUTPUT: 4

- JSON: (provides a way to share and store data. easily convertable to and from js object. very convenient data format when working with web technologies. very simple and stadardized. Always encoded with UTF-8. JSON's most commonly contain an object which contain zero or more key value pais. The key is always a string, and the value must be one of the valid JSON data types. Key value pairs are delimit arrays, and strings are larways delimited with double quotes)
  {
    "class": {
      "title": "web programming",
      "description": "Amazing"
    },
    "enrollment": ["Marco", "Jana", "فَاطِمَة"],
    "start": "2025-02-01",
    "end": null
  }

- JSON format:
  string - "crockford"
  number - 42
  boolean - true
  array - [null, 42, "crockford"]
  object - {"a":1, "b":"crockford"}
  null - null

- Converting to js: (to convert to and from JSON use JSON.parse and JSON.stringify)
  const obj = { a: 2, b: 'crockford', c: undefined };
  const json = JSON.stringify(obj);
  const objFromJson = JSON.parse(json);
  console.log(obj, json, objFromJson);
  // OUTPUT:
  // {a: 2, b: 'crockford', c: undefined}
  // {"a":2, "b":"crockford"}
  // {a: 2, b: 'crockford'}

- Regular expressions: (regex)
  const objRegex = new RegExp('ab*', 'i');
  const literalRegex = /ab*/i;

- String class has several functions that accept regular expressions including match, replace, search, and split.
  const petRegex = /(dog)|(cat)|(bird)/gim;
  const text = 'Both cats and dogs are pets, but not rocks.';
  text.match(petRegex);
  // RETURNS: ['cat', 'dog']
  text.replace(petRegex, 'animal');
  // RETURNS: Both animals and animals are pets, but not rocks.
  petRegex.test(text);
  // RETURNS: true

- Rest: (For functions that you want an unknown number of parameters. ex. function that checks to see if some number in a list is equal to a given number, you should write this using an array)
  function hasNumber(test, numbers) {
    return numbers.some((i) => i === test);
  }
  const a = [1, 2, 3];
  hasNumber(2, a);
  // RETURNS: true

  ex 2.
  function hasTwo(a, b, c) {
    return hasNumber(2, [a, b, c]);
  }

  (rest syntax makes this easier. parameter that contains the rest of the parameters. rest (...) can then call it with any number of parameters and are automatically combined into an array. Typically last so js know what is going into the array. rest allows js to provide what is valled variadic functions)
  function hasNumber(test, ...numbers) {
    return numbers.some((i) => i === test);
  }
  hasNumber(2, 1, 2, 3);
  // RETURNS: true

- Spread: (opposite of rest. Takes an object that is iterable (array or string) and expands it into a functions parameters)
  function person(firstName, lastName) {
    return { first: firstName, last: lastName };
  }
  const p = person(...['Ryan', 'Dahl']);
  console.log(p);
  // OUTPUT: {first: 'Ryan', last: 'Dahl'}

- Try and catch: (throw is also used. finally is called whenever the try block is exited)
  try {
    // normal execution code
  } catch (err) {
    // exception handling code
  } finally {
    // always called code
  }

    function connectDatabase() {
    throw new Error('connection error');
  }

  try {
    connectDatabase();
    console.log('never executed');
  } catch (err) {
    console.log(err);
  } finally {
    console.log('always executed');
  }
  // OUTPUT: Error: connection error
  //         always executed

- Fallbacks: (Used in the catch, returns something even if it is not the desired output)
  function getScores() {
    try {
      const scores = scoringService.getScores();
      // store the scores so that we can use them later if the network is not available
      window.localStorage.setItem('scores', scores);
      return scores;
    } catch {
      return window.localStorage.getItem('scores');
    }
  }

- Destructuring: (not destructing, is the process of pulling individual items out of an existing one or removing structure. Can be done with either arrays or objects. Helpful when you only care about a few items in the original structure)
  const a = [1, 2, 4, 5];
  // destructure the first two items from a, into the new variables b and c
  const [b, c] = a;
  console.log(b, c);
  // OUTPUT: 1, 2

  (using rest)
  const [b, c, ...others] = a;
  console.log(b, c, others);
  // OUTPUT: 1, 2, [4,5]

  (explicitly specify the properties you want to pull from the source object)
  const o = { a: 1, b: 'animals', c: ['fish', 'cats'] };
  const { a, c } = o;
  console.log(a, c);
  // OUTPUT 1, ['fish', 'cats']

  (can also map the names to new variables instead of using the original property names)
  const o = { a: 1, b: 'animals', c: ['fish', 'cats'] };
  const { a: count, b: type } = o;
  console.log(count, type);
  // OUTPUT 1, animals

  (default values may also be provided for missing ones)
  const { a, b = 22 } = {};
  const [c = 44] = [];
  console.log(a, b, c);
  // OUTPUT: undefined, 22, 44

  (can also use destructuring to reassign existing variables)
  let a = 22;
  [a] = [1, 2, 3];
  console.log(a);
  // OUTPUT: 1

- Object and classes: (properties of an object can be referenced with either a dot (obj.prop) or a bracket (obj['prop']))
  const obj = new Object({a:3});
  obj['b'] = 'fish';
  obj.c = [1, 2, 3];
  obj.hello = function () {
    console.log('hello');
  };
  console.log(obj);
  // OUTPUT: {a: 3, b: 'fish', c: [1,2,3], hello: func}

- Note: object can refer to the standard js objects(promise, map, object, function, date, ...) or it can refer specifically to the js Object object(new Object()), or it can refer to any js object you create({a:'a', b:2})

- Object-literals: (this syntax allows you to provide the initial composition of the object)
  const obj = {
    a: 3,
    b: 'fish',
  };

- Object functions:
  entries - returns an array pf key value pairs
  keys - returns an array of keys
  values - returns an array of values
  const obj = {
    a: 3,
    b: 'fish',
  };
  console.log(Object.entries(obj));
  // OUTPUT: [['a', 3], ['b', 'fish']]
  console.log(Object.keys(obj));
  // OUTPUT: ['a', 'b']
  console.log(Object.values(obj));
  // OUTPUT: [3, 'fish']

- Constructor: (any fuction that returns an object is considered a constructor and can be invoked with the new operator)
  function Person(name) {
    return {
      name: name,
    };
  }
  const p = new Person('Eich');
  console.log(p);
  // OUTPUT: {name: 'Eich'}

  (since objects can have any type of property value you can create methods on the object as part of its encapsulation)
  function Person(name) {
    return {
      name: name,
      log: function () {
        console.log('My name is ' + this.name);
      },
    };  
  }
  const p = new Person('Eich');
  p.log();
  // OUTPUT: My name is Eich

- Classes: (classes define objects. Using a class clarifies the intent to create a reusable component rather than a one-off object. Classes have an explicit constructor and assumed function declarations)
  class Person {
    constructor(name) {
      this.name = name;
    }
    log() {
      console.log('My name is ' + this.name);
    }
  }
  const p = new Person('Eich');
  p.log();
  // OUTPUT: My name is Eich

  (can make properties and functions of classes private by prefixing them with #)
  class Person {
    #name;
    constructor(name) {
      this.#name = name;
    }
  }
  const p = new Person('Eich');
  p.#name = 'Lie';
  // OUTPUT: Uncaught SyntaxError: Private field '#name' must be declared in an enclosing class

- Inheritance: (classes can be extended by using the extends keyword to define inheritance. Parameters that need to be passed to the parent class are delivered using the super function. Any finctions defined on the child that have the same name as the parent override the parent's implementation. A parent's function can be explicitly accessed using the super keyword)
  class Person {
    constructor(name) {
      this.name = name;
    }
    print() {
      return 'My name is ' + this.name;
    }
  }
  class Employee extends Person {
    constructor(name, position) {
      super(name);
      this.position = position;
    }
    print() {
      return super.print() + '. I am a ' + this.position;
    }
  }
  const e = new Employee('Eich', 'programmer');
  console.log(e.print());
  // OUTPUT: My name is Eich. I am a programmer

- Scope: (scope is defined as the variables that are visible in the current context of execution. js has 4 different types)
  Global - visible to all code
  Module - visible to all code running in a module
  Function - visible within a function
  Block - visible within a block of code delimited by curly braces

- Var: (Outdated, but used in specific circumstances. Ignores block scope, always logically hoisted to the top of the fuction)
  var x = 10;
  console.log('start', x);
  for (var x = 0; x < 1; x++) {
    console.log('middle', x);
  }
  console.log('end', x);
  // OUTPUT: start 10
  //         middle 0
  //         end 1

- This: (represents a variable that points to an object that contains the context within the scope of the currently executing line of code. This is automatically declared and can reference this anywhere in the js program. It has 3 different context that it can refer to)
  Global - When this is referenced outside a function or object it refers to the globalThis object. The globalThis object represents the context for runtime environment. For emaple, when running in a browser, globalThis refers to the browser's window object.
  Function - when this is referenced in a function it refers to the object that own the function. That is either an object you defined or globalThis if function is defined outside of an object. Note than when running in js strict mode, a global function's this variable is undefined instead of globalThis
  Object - when this is referenced in an object it refers to the object

  (If not in js strict mode then globalFunctionThis would refer to Window)
  'use strict';
  // global scope
  console.log('global:', this);
  console.log('globalThis:', globalThis);
  // function scope for a global function
  function globalFunc() {
    console.log('globalFunctionThis:', this);
  }
  globalFunc();
  // object scope
  class ScopeTest {
    constructor() {
      console.log('objectThis:', this);
    }
    // function scope for an object function
    objectFunc() {
      console.log('objectFunctionThis:', this);
    }
  }
  new ScopeTest().objectFunc();

  Output:
  global: Window
  globalThis: Window
  globalFunctionThis: undefined
  objectThis: ScopeTest
  objectFunctionThis: ScopeTest

- Closure: (a function and its surrounding state. That means whatever variables are accessible when a function is created are available inside the function. This holds true even if you pass the function outside of the scope of its original creation)
  globalThis.x = 'global';
  const obj = {
    x: 'object',
    f: function () {
      console.log(this.x);
    },
  };
  obj.f();
  // OUTPUT: object

  (With arrow funcitons. when it returns an arrow function, the this pointer at the time of creation will be globalThis)
  globalThis.x = 'global';
  const obj = {
    x: 'object',
    f: () => console.log(this.x),
  };
  obj.f();
  // OUTPUT: global

  (if the function in the object that returns an arrow function, then the this pointer will be the object's this pointer since that was the active context at the time of the arrow function was created)
  globalThis.x = 'global';
  const obj = {
    x: 'object',
    make: function () {
      return () => console.log(this.x);
    },
  };
  const f = obj.make();
  f();
  // OUTPUT: object

- Modules: (allows for partitioning and sharing of code. Modules create a file-based scope for the code they represent, you must explicitly export the objects from one file and them import them into another file. For example, a simple module that exports a function that displays an alert)
  export function alertDisplay(msg) {
    alert(msg);
  }

  (can use import the module's exported function into another module)
  import { alertDisplay } from './alert.js';
  alertDisplay('called from main.js');

- ES Modules in the browser:
  <script type="module">
    import { alertDisplay } from './alert.js';
    alertDisplay('module loaded');
  </script>

  (With global scope)
  <html>
    <body>
      <script type="module">
        import { alertDisplay } from './alert.js';
        window.btnClick = alertDisplay;
        document.body.addEventListener('keypress', function (event) {
          alertDisplay('Key pressed');
        });
      </script>
      <button onclick="btnClick('button clicked')">Press me</button>
    </body>
  </html>

- Document Object Model (DOM): (object representation of the HTML elements that the browser uses to render the display. The browser also exposes the DOM to external code so that you can write programs that dynamically manipulate the HTML. The browser provides access to the DOM through a global variable name document that points to the root element of the DOM. If you open the browser's debugger console window and type the variable name document, you will see the DOM for the document the browser is currently rendering)
  > document
  <html lang="en">
    <body>
      <p>text1 <span>text2</span></p>
      <p>text3</p>
    </body>
  </html>
  p {
    color: red;
  }

- Accessing the DOM: (Every element in an HTML document implements the DOM Element interface which is derived from the DOM Node interface. Allows the means for iterating child elements, accessing the parent element, and manipulating the element's attributes. From the js code, you can start with the document variable and walk through the every element in the tree)
  function displayElement(el) {
    console.log(el.tagName);
    for (const child of el.children) {
      displayElement(child);
    }
  }
  displayElement(document);

  (Can provide a CSS selector to the querySelectorAll function in order to select elements from the document. The textContent property contains all of the element's text. You can even access a textual representation of an element's HTML content with the innerHTML property)
  const listElements = document.querySelectorAll('p');
  for (const el of listElements) {
    console.log(el.textContent);
  }

- Modifying the DOM: (DOM supports the ability to insert, modify, or delete the elements in the DOM. To create a new element you first create the element on the DOM document. You then insert the new element into the DOM tree by appending it to an existing element in the tree)
  function insertChild(parentSelector, text) {
    const newChild = document.createElement('div');
    newChild.textContent = text;
    const parentElement = document.querySelector(parentSelector);
    parentElement.appendChild(newChild);
  }
  insertChild('#courses', 'new course');

  (To delete elements call the removeChild function on the parent element)
  function deleteElement(elementSelector) {
    const el = document.querySelector(elementSelector);
    el.parentElement.removeChild(el);
  }
  deleteElement('#courses div');

- Injecting HTML: (DOM also allows injection of entire blocks of HTML into an element. The following finds the first div element in the DOM and replaces all the HTML it contains. Common attack for hackers that use the DOM and inject their own code. Can request  sensitive data, monitor activity, and steal credentials.)
  const el = document.querySelector('div');
  el.innerHTML = '<div class="injected"><b>Hello</b>!</div>';

  <img src="bogus.png" onerror="console.log('All your base are belong to us')" />

- Event Listeners: (All DOM elements support the ability to attach a function that gets called when an event occurs on the element)
  const submitDataEl = document.querySelector('#submitData');
  submitDataEl.addEventListener('click', function (event) {
    console.log(event.type);
  });

- Other listening events:
  Clipboard - cut, copied, pasted
  Focus - an element gets focus
  Keyboard - keys are pressed
  Mouse - click events
  Text selection - when text is selected

  <button onclick='alert("clicked")'>click me</button>

- LocalStorage: (localStorage API provides the ability to persistently store and retrieve data (scores, usernames, etc.) on a user's browser across user sessions and HTML page renderings. Also used as a cache for when data cannot be obtained from the server)

- LocalStorage functions: (4 main functions. Local storage value must be of type string, number, or boolean. If you want to store a js object or array then it must be converted to a JSON string)
  setItem(name, value) - sets a named item's value into local storage
  getItem(name) - gets a named item's value from local storage
  removeItem(name) - removes a named item from local storage
  clear() - clears all items in local storage

  let user = 'Alice';
  let myObject = {
    name: 'Bob',
    info: {
      favoriteClass: 'CS 260',
      likesCS: true,
    },
  };
  let myArray = [1, 'One', true];

  localStorage.setItem('user', user);
  localStorage.setItem('object', JSON.stringify(myObject));
  localStorage.setItem('array', JSON.stringify(myArray));

  console.log(localStorage.getItem('user'));
  console.log(JSON.parse(localStorage.getItem('object')));
  console.log(JSON.parse(localStorage.getItem('array')));

  Output:
  Alice
  {name: 'Bob', info: {favoriteClass: 'CS 260', likesCS: true}
  [1, 'One', true]

- Promises: (js executes as a single threaded application. There is only ever one piece of code executing at the same time. Things can still run in parallel. Can asynchronously execute code with the use of a js promise. promise can be in one of 3 states at any given time)
  pending - currently running asynchronously
  fulfilled - completed successfully
  rejected - failed to complete

  (Can see this by using setTimeout)
  const delay = (msg, wait) => {
    setTimeout(() => {
      console.log(msg, wait);
    }, 1000 * wait);
  };
  new Promise((resolve, reject) => {
    // Code executing in the promise
    for (let i = 0; i < 3; i++) {
      delay('In promise', i);
    }
  });
  // Code executing after the promise
  for (let i = 0; i < 3; i++) {
    delay('After promise', i);
  }
  // OUTPUT:
  //   In promise 0
  //   After promise 0
  //   In promise 1
  //   After promise 1
  //   In promise 2
  //   After promise 2

- Resolving and rejecting: (Set state to fulfilled when things complete correctly, or to rejected when an error happens. Promise executor function takes two functions as parameters, resolve and reject)
  const coinToss = new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve('success');
      } else {
        reject('error');
      }
    }, 10000);
  });

  (Log the coinToss to the console immediately after calling the constructor displays pending state)
  console.log(coinToss);
  // OUTPUT: Promise {<pending>}

  (Wait 10 seconds it will now show fulfilled or rejected)
  console.log(coinToss);
  // OUTPUT: Promise {<fulfilled>}

- Then, catch, finally:
  const coinToss = new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.1) {
        resolve(Math.random() > 0.5 ? 'heads' : 'tails');
      } else {
        reject('fell off table');
      }
    }, 10000);
  });

  coinToss
    .then((result) => console.log(`Coin toss result: ${result}`))
    .catch((err) => console.log(`Error: ${err}`))
    .finally(() => console.log('Toss completed'));
  // OUTPUT:
  //    Coin toss result: tails
  //    Toss completed

- The observed pattern: (Observer pattern, popularized by web programming frameworks such as Angular, use a model called observer. The difference between this and promises is that promises immediately begin to execute when created, but observers form a pipeline that you can pass an execution object into. This allows the observers to be reused and the result of executing an observable to be saved as a history of a particular execution

- Async/await: (a more concise representation than promises. The await keyword wraps the execution of a promise and removed the need to chain functions. The await expression will block until the promise state moves to fulfilled or throws an exception if the state moves to rejected)
  (Promise)
  const coinToss = () => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.1) {
          resolve(Math.random() > 0.5 ? 'heads' : 'tails');
        } else {
          reject('fell off table');
        }
      }, 1000);
    });
  };

  (then/catch chain)
  coinToss()
    .then((result) => console.log(`Toss result ${result}`))
    .catch((err) => console.error(`Error: ${err}`))
    .finally(() => console.log(`Toss completed`));

    (async, try/catch)
    try {
      const result = await coinToss();
      console.log(`Toss result ${result}`);
    } catch (err) {
      console.error(`Error: ${err}`);
    } finally {
      console.log(`Toss completed`);
    }

- Async: (Transforms the function so that it returns as a promise that will resolve to the value that was previously returned by the function. Bassically this turns any function into an asynchronous function, so that it can in turn make asynchronous requests)
  function cow() {
    return 'moo';
  }
  console.log(cow());
  // OUTPUT: moo

  async function cow() {
    return 'moo';
  }
  console.log(cow());
  // OUTPUT: Promise {<fulfilled>: 'moo'}

  async function cow() {
    return new Promise((resolve) => {
      resolve('moo');
    });
  }
  console.log(cow());
  // OUTPUT: Promise {<pending>}

- Await: (wraps a call to the async function, blocks execution until the promise has resolved, and then returns the result of the promise)
  console.log(cow());
  // OUTPUT: Promise {<pending>}
  console.log(await cow());
  // OUTPUT: moo

- All together:
  const httpPromise = fetch('https://simon.cs260.click/api/user/me');
  const jsonPromise = httpPromise.then((r) => r.json());
  jsonPromise.then((j) => console.log(j));
  console.log('done');
  // OUTPUT: done
  // OUTPUT: {email: 'bud@mail.com', authenticated: true}

  const httpResponse = await fetch('https://simon.cs260.click/api/user/me');
  const jsonResponse = await httpResponse.json();
  console.log(jsonResponse));
  console.log('done');
  // OUTPUT: {email: 'bud@mail.com', authenticated: true}
  // OUTPUT: done

- Debugging js: (use console.log functions)
  HTML:
  <body>
    <h1>Debugging</h1>
    <script src="index.js"></script>
  </body>

  JS:
  var varCount = 20;
  let letCount = 20;
  console.log('Initial - var: %d, let: %d', varCount, letCount);
  for (var varCount = 1; varCount < 2; varCount++) {
    for (let letCount = 1; letCount < 2; letCount++) {
      console.log('Loop - var: %d, let: %d', varCount, letCount);
    }
  }
  const h1El = document.querySelector('h1');
  h1El.textContent = `Result - var:${varCount}, let:${letCount}`;
  console.log('Final - var: %d, let: %d', varCount, letCount);

- Use the following steps:
  Create the above files in a test directory named testConsole
  Open the testConsole directory in VS Code
  Run index.html using the VS Code Live Server extension
  Open the Chrome browser debugger (press F12)
  Select the Console tab
  Regresh the browser




  
